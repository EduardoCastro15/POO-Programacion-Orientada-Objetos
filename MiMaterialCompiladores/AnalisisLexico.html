<html>
<style>
header {
background-color: #8ba987;
display: block;
color:#FFFFFF;
text-align: center;
height:16%;
width:50%;
margin-left:25%;
border: solid;
border-color:#FFFF00;
}

h2 {  font-size: 30px;
      margin: 0px;
}

article {
background-color: #8ba987;
display: block;
margin-left: 25%;
margin-top: 0.5%;
padding: 1px;
-webkit-border-radius: 10px;
-moz-border-radius: 10px;
border-radius: 10px;
-webkit-box-shadow: 2px 2px 20px #888;
-webkit-transform: rotate(-0deg);
-moz-box-shadow: 2px 2px 20px #888;
-moz-transform: rotate(-0deg);
width:50%;	
height:25%;	
}

article header {
background-color: #009F80;
-webkit-border-radius: 10px;
-moz-border-radius: 10px;
border-radius: 10px;
border-color:#800000;
padding: 2px;
height: auto;
width:44%;
text-align: center;
font-size: 20px;
margin-left:26%;
margin-bottom: 5%;
margin-top: 5%;
}

article h1 {
font-size: 20px;

}

article div{
background-color: #8ba987;
-webkit-border-radius: 10px;
-moz-border-radius: 10px;
border-radius: 10px;
border-color:#0000FF;
padding: 5px;
width:40%;
text-align: center;
margin-left:0%;
}

p.par1  {
 background-color: #808080;
 font-size: 28px;
 width: 200px;
 margin: 10px auto;
 padding: 5px;
 border: solid 6px #00f;
 font: normal 15px arial, helvetica, sans-serif;
 }

p.p2  {
 background-color: #808080;
 font-size: 28px;
 width: 500px;
 margin: 10px auto;
 padding: 5px;
 border: solid 6px #00f;
 font: normal 15px arial, helvetica, sans-serif;
 }

p.p3  {
 background-color: #808080;
 font-size: 28px;
 width: 500px;
 margin: 10px auto;
 padding: 5px;
 border: solid 6px #f60;
 font: normal 15px arial, helvetica, sans-serif;
 }

pre.p2  {
 background-color: #808080;
 font-size: 28px;
 width: 500px;
 margin: 10px auto;
 padding: 5px;
 border: solid 6px #80A93E;
 font: normal 15px arial, helvetica, sans-serif;
 }

	.modalDialog {
		position: fixed;
		font-family: Arial, Helvetica, sans-serif;
		top: 0;
		right: 0;
		bottom: 0;
		left: 0;
		background: rgba(0,0,0,0.2);
		z-index: 99999;
		opacity:0;
		-webkit-transition: opacity 400ms ease-in;
		-moz-transition: opacity 400ms ease-in;
		transition: opacity 400ms ease-in;
		pointer-events: none;
	}
	.modalDialog:target {
		opacity:1;
		pointer-events: auto;
	}
	.modalDialog > div {
		width: 30%;
		position: relative;
		margin: 10% auto;
		padding: 5px 20px 13px 20px;
		border-radius: 10px;
		background: #fff;
		background: -moz-linear-gradient(#fff, #999);
		background: -webkit-linear-gradient(#fff, #999);
		background: -o-linear-gradient(#fff, #999);
	  	-webkit-transition: opacity 400ms ease-in;
		-moz-transition: opacity 400ms ease-in;
		transition: opacity 400ms ease-in;
	}
	.close {
		background: #606061;
		color: #FFFFFF;
		line-height: 25px;
		position: absolute;
		right: -12px;
		text-align: center;
		top: -10px;
		width: 24px;
		text-decoration: none;
		font-weight: bold;
		-webkit-border-radius: 12px;
		-moz-border-radius: 12px;
		border-radius: 12px;
		-moz-box-shadow: 1px 1px 3px #000;
		-webkit-box-shadow: 1px 1px 3px #000;
		box-shadow: 1px 1px 3px #000;
	}
.close:hover { background: #00d9ff; }

table {
  margin-left: 15%;
  padding: 15px;
}

body{
font-size: 20px;
}
</style>

<head>
<title>Análisis Léxico</title>
</head>

<body bgcolor=gray text=white link=yellow vlink=lime>

<a>
<img src="LibCompiladores.svg" align=left alt="seleccione aquí para visitar la página oficial de Instraw" width=24% border=0>
</a>

<a>
<img src=CapAnalisisLexico.svg align=right alt="seleccione aquí para visitar la página oficial del material" width=24.5% height=45% border=0>
</a>

<header>
<img src=Estudiante.svg align=left alt="seleccione aquí para visitar la página oficial del material" width=16% height=97% border=0>

<img src=CapAnalisisLexico.svg align=right alt="seleccione aquí para visitar la página oficial del material" width=16% height=97% border=0>

<h1 align=center>
<font color=maroon size=8>
CAPÍTULO 2
</font>
</h1>

<h2 align=center>
<font color=white size=6>
Análisis Léxico
</font>
</h2>
</header>

<hr>


<nav>
<h3 align=center><font size=6>Índice</font></h3>

<p align=center><font size=5>
El material de estudio para el estudiante que se presenta en esta página, esta dividido de acuerdo al temario de la asignatura.</font></p>



<a href=#def>Definición de las clases léxicas por medio de expresiones regulares.</a>
&nbsp; &nbsp;
<a href=#ana>Análisis Léxico.</a>
&nbsp; &nbsp;
<a href=#cre>Creación de AFN por medio de la construcción de Thompson.</a>
&nbsp; &nbsp;
<a href=#con>Conversión de AFN a AFD.</a>
&nbsp; &nbsp;
<a href=#afd>Creación de un AFD a partir de una expresión regular.</a>
&nbsp; &nbsp;
<a href=#min>Minimización de estados de un AFD.</a>
&nbsp; &nbsp;
<a href=#cons>Construcción de analizadores léxicos definidos por medio de expresio-
nes regulares.</a>
&nbsp; &nbsp;
<a href=#gen>Generadores de analizadores léxicos.</a>
</nav>


<hr>


<article>
<div class="section-content" style="width:900px;">
<p style="text-align: center; ">El analizador léxico es también llamado escaner, su función es reconocer una
cadena de caracteres para identificar las palabras del lenguaje en estudio. La
forma de ir reconociendo el carácter que forma a la palabra, se hace acoplando
la cadena de caracteres en estudio a una gramática por medio de un autómata.
Al final el autómata reconoce si la cadena de caracteres es una palabra válida.
Las palabras que debe reconocer el escaner, son: los números, los identificadores,
las palabras reservadas, los operadores y los delimitadores.</p>

<header>
<h3 align="center" id=def>Definición de las clases léxicas por medio de expresiones regulares.</h3>
</header>

<p>Todo lenguaje de programación se expresa por medio de cinco tokens, los
cuales están agrupados en clases léxicas. Las clases léxicas son los tipos de
palabras que se usan en programación, tales son: los números, los identificadores,
las palabras reservadas, los operadores y los delimitadores. Estas clases léxicas,
también llamadas tokens, se pueden expresar por medio de expresiones regulares.</p>

<font color=yellow><h4 align="center">Expresiones regulares</h4></font>

<p>Todo lenguaje tiene tipos de palabras que ayudan a expresar las ideas. El
lenguaje de programación también tiene tipos de palabras, que permiten expresar las ideas por medio de algoritmos. Los tipos de palabras que tiene cada
lenguaje de programación se pueden clasificar, en: números, identificadores, palabras clave, operadores y delimitadores.</p>

<p>Se muestra en el siguiente listado ejemplos de tokens:</p>

<table CELLSPACING="18">
<tr><td>1</td><td>Números: 1, 2, 3, 4, 0.5, 0.6, 0.7, etc.</td></tr>
<tr><td>2</td><td>Identificadores: a, b, c, d, a1, b2, A, A1, etc.</td></tr>
<tr><td>3</td><td>Palabras clave: int, float, main, new, etc.</td></tr>
<tr><td>4</td><td>Operadores: +, -, *, /, etc.</td></tr>
<tr><td>5</td><td>Delimitadores: , , [, ], etc.</td></tr>
</table>


<font color=yellow><h3 align="center">Clases léxicas</h3></font>

<p>El término letra y carácter se usará como sinónimo de sı́mbolo para denotar un elemento de un alfabeto. Si se pone una secuencia de sı́mbolos lado a
lado, se tiene una cadena de sı́mbolos. Por ejemplo, 01011 es una cadena del
alfabeto binario {0, 1 }. El término sentencia y palabra son frecuentemente
usadas como sinónimos de cadena [?] .</p>

<p>Se formaliza la idea de una gramática y cómo se usa. Para este propósito,
sea V T un conjunto finito de sı́mbolos no vacı́o llamado alfabeto terminal. Los
sı́mbolos en V T se llaman sı́mbolos terminales. El metalenguaje que se usa para
generar cadenas en el lenguaje se supone que contiene un conjunto de clases
sintácticas o variables llamadas sı́mbolos no terminales. El conjunto de sı́mbolos
no terminales es denotado por V N y los elementos de V N se utilizan para definir
la sintaxis (estructura) del lenguaje. Además, se supone que los conjuntos V N y
V T son disjuntos [7].</p>


<p class="par1">
DEFINICIÓN <b>1</b> (Vocabulario.) Es el conjunto V N ∪ V T que
consiste en sı́mbolos no terminales y terminales [7].
</p>


<p class="par1">
DEFINICIÓN <b>2</b> (Lenguaje.) Es un conjunto de cadenas de
longitud finita sobre algún alfabeto finito Σ [?] .
</p>



<p>La expresión regular se define como la representación de las palabras por
medio de cadenas de sı́mbolos, donde se utiliza la notación algebraica, la cual
es reducida y fácil de asimilar. Esta representación se hace por medio de tres
operaciones algebraicas de los sı́mbolos: la concatenación, la concatenación de
los caracteres de cero a más veces (cerradura) y la alternativa.</p>

<p class="p2">
DEFINICIÓN <b>3</b> (Conjunto regular.) Sea Σ un alfabeto finito. Un conjunto regular es recursivo sobre el alfabeto Σ de la
siguiente manera:

<table CELLSPACING="18">
<tr><td>1</td><td>Φ es una conjunto regular sobre Σ.</td></tr>
<tr><td>2</td><td>{e} es una conjunto regular sobre Σ.</td></tr>
<tr><td>3</td><td>{a} es una conjunto regular sobre Σ.</td></tr>
<tr><td>4</td><td>Si P y Q son conjuntos regulares sobre Σ, entonces:

	<table CELLSPACING="18">
	<tr><td>a</td><td>P ∪ Q.</td></tr>
	<tr><td>b</td><td>PQ.</td></tr>
	<tr><td>c</td><td>P ∗ .</td></tr>
	</table>

</td></tr>
<tr><td>5</td><td>Nada también es un conjunto regular.</td></tr>
</table>
</p>

<p class="p2">
DEFINICIÓN <b>4</b> (Expresión regular.) Sea Σ un alfabeto finito. Una expresión regular es una definición recursiva, como se
presenta en el siguiente listado:

<table CELLSPACING="18">
<tr><td>1</td><td>Φ es una expresión regular que denota el conjunto regular
{Φ}.</td></tr>
<tr><td>2</td><td>e es una expresión regular que denota el conjunto regular
{e}.</td></tr>
<tr><td>3</td><td>a ∈ Σ es una expresión regular que denota el conjunto regular {a}.</td></tr>
<tr><td>4</td><td>Si p y q son expresiones regulares que denota el conjunto
regular P y Q respectivamente, entonces :

<table CELLSPACING="18">
	<tr><td>a</td><td>(p + q) es una expresión regular que denota P ∪ Q.</td></tr>
	<tr><td>b</td><td>(pq) es una expresión regular que denota PQ.</td></tr>
	<tr><td>c</td><td>(p) ∗ es una expresión regular que denota P ∗ .</td></tr>
	</table>

</td></tr>

<tr><td>5</td><td>Nada también es una expresión regular.</td></tr>
</table>
</p>


<font color=yellow><h3 align="center">Las operaciones básicas de las expresiones regulares</h3></font>

<p>
Las operaciones básicas de las expresiones regulares, son: la concatenación, la alternativa y la cerradura. Con estas operaciones se forma cualquier expresión regular.
</p>


<font color=yellow><h4 align="center">La concatenación</h4></font>

<p>La concatenación es la consecución de sı́mbolos, uno después de otro. Ası́ que
la concatenación de los sı́mbolos a y b se expresa, como:</p>

<font color=red><h2 align="center">ab</h2></font>

<p>Sean <b>R</b> y <b>S</b> dos cadenas de sı́mbolos, la concatenación de las dos cadenas
se denota como: <b>RS</b>. Se define por medio de la notación de conjuntos, como a
continuación se muestra: <b>{xy|x ∈ R ∧ Y ∈ S}</b>.
Un solo sı́mbolo es por si solo una expresión regular, ya que es la concatenación del sı́mbolo con la cadena vacı́a una o más veces. Sea  la representación
de la cadena vacı́a. El sı́mbolo a, se expresa como la concatenación de la cadena
vacı́a una o más veces con el sı́mbolo, de la siguiente manera:</p>

<font color=red><h4 align="center">a = a&epsilon; = a&epsilon; &epsilon; = a&epsilon; &epsilon; &epsilon; · · ·</h4></font>

<p>Por lo que, una cadena con un sólo sı́mbolo, es  de por sı́, una expresión regular.
Reafirmando: a, b, &epsilon;, son expresiones regulares.</p>


<font color=yellow><h4 align="center">La alternativa</h4></font>

<p>Cuando se quiere reconocer un sı́mbolo u otro sı́mbolo, la notación algebraica
que lo determina, es la siguiente:</p>

<p>Esto quiere decir que se lee a o se lee b. Sean R y S dos cadenas de sı́mbolos, la
alternativa de dos cadenas se define como <b>{x|x ∈ R ∨ x ∈ S}</b>. Su representación,
es:</p>

<font color=red><h2 align="center">a|b</h2></font>


<font color=yellow><h4 align="center">Las cerraduras</h4></font>

<p>La concatenación de sı́mbolos cero o más veces hasta el infinito se hace por
medio de las cerraduras de Kleene y la concatenación de una o más veces hasta
el infinito se hace por medio de la cerradura positiva. La cerradura de Kleene o
transitiva se representa de la siguiente manera:</p>



<font color=red><h4 align="center">La cerradura de kleene</h4></font>

Se representa por medio de la concatenación que se formaliza con la siguiente expresión:
<p><font color=red align="center" size="8"> &cup;<SUB>i = 0</SUB><SUP>&infin;</SUP>&nbsp; a<SUP>i</SUP> = a<SUP>*</SUP></font></p>


<font color=red><h4 align="center">La cerradura positiva</h4></font>

<p>También se representa por medio de la concatenación que se formaliza con la siguiente expresión:</p>

<p><font color=red align="center" size="8"> &cup;<SUB>i = 1</SUB><SUP>&infin;</SUP>&nbsp;a<SUP>i</SUP> = a<SUP>+</SUP></font></p>

<font color=yellow><h4 align="center">Determinación de Tokens de un fragmento de código</h4></font>

<p>Ası́ que observemos un fragmento de código en un lenguaje de programación. Por ejemplo en el lenguaje C++ o en Java:</p>

<font color=yellow><h5 align="center">Listado 1: Fragmento de código Java.</h5></font>

<pre class="p2">
Public class MinTest{
public static void main ( string [ ] args ) {
int a =3;
int b=7;
System . out . println ( min ( a , b ) ) ;
		}
	{
	return x mayor que y ? x : y ;
	}
}
</pre>


<p>Del código en Java del listado 1 se extraen los tokens, tales como las palabras
reservadas: int, return, public, estatic, etc. Los identificadores: a, b, x, etc. Los
números, 3, 7, etc. Los operadores: <, ?. Los delimitadores: (, ), ;, etc.</p>

<p>Se muestran ejemplos de expresiones regulares en la siguiente lista:</p>


<table CELLSPACING="18">
<tr><td>1</td><td>Números: 1, 2, 3, 4, 0.5, 0.6, 0.7, etc.</td></tr>
<tr><td>2</td><td>Identificadores: a, b, c, d, a1, b2, A, A1, etc.</td></tr>
<tr><td>3</td><td>Palabras clave: int, float, main, new, etc.</td></tr>
<tr><td>4</td><td>Operadores: +, -, *, /, etc.</td></tr>
<tr><td>5</td><td>Delimitadores: , , [, ], etc.</td></tr>
</table>

<header>
<h4 align="center" id=ana>Análisis Léxico</h4>
</header>

<p>Cuando el compilador analiza un programa escrito en un lenguaje de alto
nivel. El primer paso es reconocer las palabras contenidas en el programa, de
acuerdo a las clases léxicas [3]. Las palabras se van leyendo sı́mbolo por sı́mbolo
y al agrupar todos los caracteres, se forman las palabras, las cuales se comparan
con un conjunto de reglas, que se representan por medio de expresiones regulares
o por medio de gramáticas. Si la palabra es válida, de acuerdo al lenguaje de
programación usado acoplado con las reglas de una expresión regular o una
gramática, el escaner asigna una clase léxica o categorı́a sintáctica, o la reconoce
como parte del programa.</p>


<img src="ALexFig1.svg" align=center alt="seleccione aquí para visitar la página oficial de Instraw" width=44% border=0>

<p>De esta manera se sabe si en el programa las palabras estan bien escritas
Existen herramientas automáticas para generar escaners. El proceso de la
herramienta es una descripción matemática de la sintaxis léxica del lenguaje.
Para construir los escaners artesanales y los escaneres generados, se aplican
las mismas técnicas en ambos. Los compiladores comerciales y los compiladores
de código abierto usan escaneres artesanales [5]. Los escaners artesanales son
más rápidos que los escaners generados, porque la implementación optimiza
una porción del encabezado que no se puede evitar en un escaner generado.
El modelo de reconocedor, es un programa que identifica las palabras de una
cadena de caracteres.
Reconocedor de palabras, la explicación más simple de un algoritmo para
reconocer palabras es reconocer carácter por carácter. Por ejemplo reconocer la
palabra clave new. Considerando la rutina SiguienteCaracter() que regresa el
siguiente carácter, se implementa como sigue:</p>


<img src="ALexAlg1.svg" align=center alt="seleccione aquí para visitar la página oficial de Instraw" width=44% border=0>

<p>
El Algoritmo 2, es la función que hace la lectura de los símbolos que forman la palabra:
</p>

<img src="ALexAlg2.svg" align=center alt="seleccione aquí para visitar la página oficial de Instraw" width=44% border=0>


<header>
<h3 align="center" id=cre>Creación de AFN por medio de la
construcción de Thompson.</h3>
</header>

<p>Las clases léxicas, se representan con las siguientes operaciones básicas, las
cuales son: la concatenación, la alternativa, la cerradura de Kleene y la cerradura
positiva. A partir de estas operaciones básicas se construye el autómata AFN,
que va a reconocer a los tokens que forman el lenguaje de programación.</p>

<font color=yellow><h4 align="center">Autómata finito no determinı́stico (AFN).</h4></font>

<p>El autómata finito no determinista se abrevia como AFN. Este autómata
se define como aquel que tiene transiciones con la cadena vacı́a &epsilon; y que tiene
transiciones de un estado con el mismo sı́mbolo a dos estados diferentes. Y el
número de los estados que componen al AFN son finitos.</p>


<img src="ALexFig2.svg" align=center alt="seleccione aquí para visitar la página oficial de Instraw" width=44% border=0>

<p>El autómata de la figura 2, tiene una transición del estado 0 al estado 1 con
la cadena vacı́a &epsilon;. Además tiene dos transiciones con el sı́mbolo b del estado 3 a
los estados 0 y 4. Por lo que este autómata es AFN.</p>


<img src="ALexFig3.svg" align=center alt="seleccione aquí para visitar la página oficial de Instraw" width=44% border=0>

<font color=yellow><h4 align="center">Construcción de Thompson.</h4></font>

<p>Tomando en cuenta las operaciones básicas de las expresiones regulares, se
plantea la construcción del AFN: para la concatenación ab, se representa por el
grafo de la figura 4 [5].</p>


<img src="ALexFig4.svg" align=center alt="seleccione aquí para visitar la página oficial de Instraw" width=54% border=0>

<p>La construcción de thompson para la cerradura de Kleene, en notación algebraica es a<SUP>∗</SUP> , el grafo es el de la figura 5 [5]:</p>

Figura 5.

<p>La construcción de thompson para la cerradura de positiva, en notación
algebraica es a<SUP>+</SUP> , el grafo es el de la figura 6 [4]:</p>

Figura 6.

<p>La construcción de Thompson para la alternativa, en notación algebraica es
a|b, el grafo es el de la figura 7 [5]:</p>

Figura 7.







<p class="p3">
EJEMPLO 1 (Construcción de Thompson.) La
entrada del analizador léxico es el código fuente y la salida son los tokens
reconocidos en el código fuente de la entrada. Ası́ que para
reconocer los tokens, se hace de dos formas: por medio de las
expresiones regulares o por medio de los autómatas.
<br>
Si tenemos la palabra reservada if, la expresión regular de esta
palabra reservada es Itálica{if}.
</p>

<p>El AFN de la expresión regular Itálica{if}, es el que se muestra en la figura
11 , el cuál representa la concatenación del sı́mbolo i con el sı́mbolo f.</p>

Figura 8.



<p class="p3">
EJEMPLO 2 (Construcción de Thompson.) Ahora
la
entrada del analizador léxico es una alternativa y la salida son
los tokens reconocidos en el código fuente de la entrada. Ası́ que
para reconocer los tokens, se hace de dos formas: por medio de
las expresiones regulares o por medio de los autómatas.
<br>
Si tenemos la expresión regular Itálica{(a | b)}.
</p>

<p>Su AFN es el que se muestra en la figura 9 .</p>

Figura 9.



<p class="p3">
EJEMPLO 3 (Construcción de Thompson.) Ahora
entrada del analizador léxico es un identificador.
<br>
La expresión regular del identificador es Itálica{l(l|d) ∗ }.
</p>

<p>Su AFN es el que se muestra en la figura 10 .</p>

Figura 10.

<header>
<h4 align="center" id=con>Conversión de AFN a AFD</h4>
</header>

<p>Existe un AFD equivalente a un AFN con transiciones &epsilon;, el que se puede
obtener de la siguiente manera:
Sea M=(Q, Σ, δ, q<SUB>0</SUB> , F) un AFN con transiciones &epsilon;. Un AFD equivalente a
un AFN será como sigue:
M’=(Q<SUB>1</SUB> , Σ, δ<SUB>1</SUB> , q<SUB>1</SUB> , F<SUB>1</SUB> ), donde Q<SUB>1</SUB> es subconjunto de 2 Q , lo que quiere decir
que cada estado de un AFD corresponde a un subconjunto de Q.
Para cada subconjunto de estados de M habrá un solo estado de M’. Donde
M’ simulará el comportamiento del autómata M, haciendo transiciones entre sus
estados de la forma que M hace las transiciones entre sus subconjuntos.</p>


<p class="p2">
DEFINICIÓN 5 (Cerradura-&epsilon;.) La cerradura-&epsilon;({S}) es el
conjunto de todos los estados que reciben una transición con el
carácter vacı́o &epsilon;, incluido el conjunto de estados {S} de donde
salen las transiciones &epsilon;.
</p>


<p>El primer estado q<SUB>1</SUB> = cerradura-&epsilon;({q<SUB>0</SUB> }), es el estado inicial del AFD. Se
agregará q<SUB>1</SUB> a Q<SUB>1</SUB> , y luego se encuentra la transición de q<SUB>1</SUB> de la siguiente manera:
δ (q<SUB>1</SUB> , a) = cerradura-&epsilon; (δ (representación del subconjunto q<SUB>1</SUB> , a)).
Si esta transición genera un nuevo subconjunto de Q, entonces este será agregado a Q<SUB>1</SUB> ; y la siguiente transición de este se deberá encontrar, se continuará de
esta manera hasta que no se pueda agregar un nuevo estado a Q<SUB>1</SUB> .
Después se identificará los estados del AFD que contengan al menos un esta-
do que pertenezca al conjunto de estados F. Si la cerradura-&epsilon;({q<SUB>0</SUB> }) no contiene
un miembro de F y el conjunto de los estados del AFD constituye F<SUB>1</SUB> , pero si la
cerradura-&epsilon;({q<SUB>0</SUB> }) contiene un miembro de F.
De [3] la transformación de AFN a AFD por medio de subconjuntos, se hace
de la siguiente manera.
Aplicando los siguientes conceptos:
Cerradura-&epsilon;({s}), es el conjunto de estados del AFN alcanzables desde el
estado s del AFN con transiciones &epsilon; solamente.
Cerradura-&epsilon;({T }), es el conjunto de estados del AFN alcanzables desde el
estado s en el conjunto T con transiciones &epsilon; solamente; ∪ s∈T cerradura − &epsilon;(s).
mover(T , a), es el conjunto de estados del AFN a los cuales hay una transición
con un sı́mbolo de entrada a desde algún estado s en T .
Se exploran los conjuntos de estados de N que pueden ver después las cadenas
de entrada. Como base, antes de leer el primer sı́mbolo de entrada, N puede estar
en cualquiera de los estados de la cerradura-&epsilon;({s<SUB>0</SUB> }), donde s<SUB>0</SUB> es el estado inicial.
Se supone que N puede estar en el conjunto de estados T después de leer la
cadena de entrada x. Si hay un lectura a, entonces N puede inmediatamente ir a
cualquiera de los estados mover(T, a). Sin embargo después de leer a este puede
hacer algunas transiciones &epsilon;; ası́ que N podrı́a estar en algunos de los estados
cerradura-&epsilon;((mover(T, a)) después de leer la entrada xa. Siguiendo estas ideas,
la construcción del conjunto de estados D’s, D estados , y su función de transición
D transicion se muestra en el siguiente algoritmo:</p>

Algoritmo 3.

<p>El estado inicial de D es cerradura-&epsilon;({s 0 }), y el estado de aceptación de
D son todos los conjuntos de estados N’s que incluyen al menos un estado de
aceptación N .</p>

Algoritmo 4.

<font color=yellow><h4>Algoritmo de subconjuntos.</h4></font>

<p>La transformación de un AFN a un AFD se hace aplicando el algoritmo
de subconjuntos, el cual comienza al aplicar cerradura-&epsilon; al primer estado del
AFN. El concepto de cerradura, es: al estado al que se le aplica la cerradura-&epsilon;
se incluye en el conjunto y además todos los estados que se accedan por medio
de un transición &epsilon; a partir del estado al que se le aplica la cerradura-&epsilon;. Se
van formando subconjuntos de estados, los cuales también se van formado del
movimiento de todos los caracteres que acepta el AFN desde el estado al que
se obtuvo, ası́ si los subconjuntos de estados son diferentes se marcan como un
estado nuevo para el AFD.</p>


<p class="p2">
DEFINICIÓN 6 (Movimiento(Estado, Sı́mbolo).) Es el
movimiento de un estado marcado como Estado con cada sı́mbolo
del alfabeto Σ hacia otro estado. El movimiento se puede expresar
también como mov(estado, sı́mbolo).
</p>

<p>Observar el siguiente ejemplo:</p>


<p class="p3">
EJEMPLO 4 (Conversión de AFN a AFD.) La siguiente
expresión regular Itálica{(a|b) ∗ ba} transformarla en AFN,
aplicando la construcción de Thompson. Para después aplicar el
algoritmo de subconjuntos y ası́ transformar el AFN a AFD.
</p>

<p>El AFN que se obteniene aplicando los patrones de la construcción de Thompson, es el que aparece en la figura 11 :</p>

Figura 11.

<p>Para transformar el AFN de la figura 11 a AFD, se aplica el algoritmo de subconjuntos. Se comienza aplicando la operación de cerr-&epsilon; al estado 0, este primer
subconjunto de estados será el primer estado del AFD, el que se etiquetará como
S 0 :</p>

<font color=red><h4>cerr−&epsilon;({0}) = {0, 1, 2, 4, 7} = S<SUB>0</SUB></h4></font>

<p>Para obtener el estado S<SUB>1</SUB> se aplica la operación de movimiento por todo el
alfabeto Σ = {a, b}, también a cada movimiento se le aplica la operación de
cerr-&epsilon;, como se muestra a continuación:</p>

<font color=red><h4>mov(S<SUB>0</SUB> , a) = {5}</h4></font>

<p>Se le aplica la operación de cerr-&epsilon; al movimiento de S<SUB>0</SUB> con el sı́mbolo a, por
lo que se obtiene:</p>

<font color=red><h4>cerr − &epsilon;(mov(S<SUB>0</SUB> , a)) = {1, 2, 4, 5, 6, 7} = S<SUB>1</SUB></h4></font> 

<p>Se hacen las siguientes operaciones:</p>
<font color=red><h4>mov(S<SUB>0</SUB> , b) = {3, 8}</h4></font>
<font color=red><h4>cerr − &epsilon;(mov(S<SUB>0</SUB> , b)) = {1, 2, 3, 4, 6, 7, 8, 9} = S<SUB>2</SUB></h4></font>

<p>Se hacen las siguientes operaciones:</p>
<font color=red><h4>mov(S<SUB>1</SUB> , a) = {5}</h4></font>
<font color=red><h4>cerr − &epsilon;(mov(S 1 , a)) = S<SUB>1</SUB></h4></font>

<p>Se hacen las siguientes operaciones:</p>
<font color=red><h4>mov(S<SUB>1</SUB> , b) = {3, 8}</h4></font>
cerr − &epsilon;(mov(S<SUB>1</SUB> , b)) = S<SUB>2</SUB>
Se hacen las siguientes operaciones:
<font color=red><h4>mov(S<SUB>0</SUB> , a) = {5}</h4></font>mov(S 2 , a) = {5, 10}
cerr − &epsilon;(mov(S<SUB>2</SUB> , a)) = {1, 2, 4, 5, 6, 7, 10} = S<SUB>3</SUB>
Se hacen las siguientes operaciones:
<font color=red><h4>mov(S<SUB>0</SUB> , a) = {5}</h4></font>mov(S 2 , b) = {3, 8}
cerr − &epsilon;(mov(S<SUB>2</SUB> , b)) = S<SUB>2</SUB>

<p>Se hacen las siguientes operaciones:</p>
<font color=red><h4>mov(S<SUB>3</SUB> , a) = {5}</h4></font>
<font color=red><h4>cerr − &epsilon;(mov(S<SUB>3</SUB> , a)) = S<SUB>1</SUB></h4></font>

<p>Se hacen las siguientes operaciones:</p>
<font color=red><h4>mov(S<SUB>3</SUB> , b) = {3, 8}</h4></font>
<font color=red><h4>cerr − &epsilon;(mov(S<SUB>3</SUB> , b)) = S<SUB>2</SUB></h4></font>

<p>El siguiente paso es obtener de las operaciones anteriores el AFD, como se
muestra en la figura 12 .</p>

Figura 12.

<header>
<h3 align="center" id=afd>Creación de un AFD a partir de una
expresión regular</h3>
</header>

<p>El proceso de construcción de un AFD de una expresión regular, es: aplicar
la construcción de Thompson a la expresión regular para obtener un autómata
AFN, para después aplicar el algoritmo de subconjuntos al AFN para obtener
un AFD no mı́nimo, como se muestra en la figura 13.</p>

Figura 13.

JEMPLO

Definición 7.

Definición 8 9, 10, 11.

Listado 2.


<font color=yellow><h4 align="center">Ejercicio.</h4></font>

<p>Convertir la expresión regular aumentada Itálica { (a|b) ∗ abb# } en un
AFD, utilizando las funciones primerapos, últimapos, siguientepos. Lo primero
es colocar en un árbol sintáctico la expresión regular. Existen los nodos: nodo-
ast que es el nodo para una cerradura de Kleene, el nodo-cat que es el nodo
para la concatenación, el nodo-o que es el nodo para la alternativa y también el
nodo-pos que es el nodo para la cerradura positiva.</p>

Figura 14.

<p>En la expresión regular Itálica{ (a|b) ∗ abb } se enumeran los sı́mbolos del
alfabeto incluido el sı́mbolo #, como se muestra en el cuadro 2 :</p>

Cuadro 1.

<p>En el árbol se marcan los nodos en la parte izquierda del nodo se colocan
los primeros y en la parte derecha del nodo se colocan los últimos.</p>

Figura 15.

<p>Para calcular la función siguientepos se aplican las siguientes dos reglas:</p>

<table CELLSPACING="18">
<tr><td>1</td><td>Si n es un nodo-cat con hijo izquierdo c<SUB>1</SUB> e hijo derecho c<SUB>2</SUB> , e<SUB>i</SUB> es una posición dentro de últimapos(c<SUB>1</SUB> ), entonces todas las posiciones de primerapos(c<SUB>2</SUB> )
están en siguientepos(i).</td></tr>

<tr><td>2</td><td>Si n es un nodo-ast, e i es una posición dentro de últimapos((n), entonces todas las posiciones de primerapos(n) están en siguientepos(i).</td></tr>

</table>


<p>En el cuadro ?? se listan los conjuntos primeros y últimos:</p>

cuadro 2.

<p>Se obtiene el autómata AFD de la figura 2.</p>

<header>
<h3 align="center" id=min>Minimización de estados de un AFD</h3>
</header>

<p>Después de transformar un autómata AFN a AFD, es conveniente que el
AFD tenga el mı́nimo de estados con la finalidad de que cuando se programe el
AFD sea con un número de estados pequeño.
Para minimizar un AFD existen algoritmos de Minimización, los cuales, son:
El algoritmo de Hopcroft [5], el algoritmo de consistencia [4].</p>



<font color=yellow><h4 align="center">El algoritmo de Hopcroft.</h4></font>

<p>Se forma un conjunto de particiones P del autómata a minimizar. La construcción del conjunto de particiones se basa en el principio de que un estado se
comporta de la misma manera que otro estado, si tienen el mismo comportamiento ante la misma cadena de entrada, entonces los estados son equivalentes.
Ası́ es, se expresa de la siguiente manera. Ante la entrada de la cadena de ca-
racteres abc, el comportamiento de un estado p → q es el mismo que el de
otro estado p<SUB>1</SUB> → q<SUB>1</SUB> , entonces los estados q y q<SUB>1</SUB> son equivalentes. Representado
gráficamente:</p>

<font color=red><h4 align="center">p −−−−−−−−−−−→ q</h4></font>

<p>Se tiene que el estado q 1 tiene el mismo comportamiento que q, ante la misma
cadena de entrada, lo que se representa de la siguiente forma:</p>

<font color=red><h4 align="center">p<SUB>1</SUB> −−−−−−−−−−−→ q<SUB>1</SUB> </h4></font>

<font color=yellow><h4 align="center">El algoritmo de consistencia.</h4></font>

<p>La manera de minimizar el número de estados es determinar las salidas
de cada uno de los estados basados en que hacen de acuerdo a la cadena de
caracteres que aceptan los estados.
Dado un AFD D que acepta el alfabeto Σ con estado S donde F ⊆ S
es el conjunto de los estados de aceptación, construimos un AFD D 0 donde
cada estado es un grupo de estados de D. Los grupos en el AFD mı́nimo son
consistentes: para cada par de estados s<SUB>1</SUB> , s<SUB>2</SUB> en el mismo grupo G y cualquier
sı́mbolo c, mover(s<SUB>1</SUB> , c) esta en el mismo grupo G<SUB>1</SUB> como mover(s<SUB>2</SUB> , c) o ambos
son indefinidos. En otras palabras, no podemos decir s<SUB>1</SUB> y s<SUB>2</SUB> aparte por buscar
sus tradiciones.
Se forman dos grupos de estados: los estados finales y los estados no finales.
Se verifica la consistencia de los grupos formados. Si no son consistentes se
divide el grupo, tomando los grupos de estados que si sean consistentes y se
reemplaza el grupo que no fué consistente por los nuevos grupos formados.
Esto se repite hasta que todos los grupos sean consistentes.</p>

<font color=yellow><h4 align="center">Ejemplo</h4></font>

<p>Se tiene el siguiente autómata AFD no mı́nimo: con el conjunto de estados
S = {0, 1, 2, 3, 4}, donde la tabla de transiciones se representa en el cuadro 3:</p>

Cuadro 3.

<p>El autómata AFD no mı́nimo de la tabla de transiciones 3, esta representado
en la figura 16 : los estados finales F = {0} y el conjunto de los estados no finales
G = {1, 2, 3, 4}.</p>

Figura 16.

<p>Para minimizar el autómata de la figura 16, se aplica el algoritmo de con-
sistencia a los dos grupos formados: el grupo de estados no finales G y el grupo
de estados finales F .
Se presentan los grupos G y F en forma de tabla, como se muestra en el
cuadro 4 y en el cuadro 5, respectivamente:</p>

Cuadro 4.


<p>Al aplicar la consistencia al grupo G representado en el cuadro 4 , se determina que todos los estados son inconsistentes, pues tienen diferentes transiciones.
Por lo que cada estado se divide en un grupo diferente, de manera que se obtienen cuatro grupos.
Al aplicar la consistencia al grupo F representado en el cuadro 5 , y ya que
tiene un sólo estado se considera que el grupo F es consistente, por lo que se
obtiene un grupo.</p>

Cuadro 5.

<p>En total se obtuvieron cinco grupos consistentes y ya que el AFD no mı́nimo
tiene cinco estados. Entonces, se concluye que el AFD no mı́nimo es el AFD
mı́nimo.</p>

<font color=yellow>Lista de ejercicios</font>

<table CELLSPACING="18">
<tr><td>1</td><td>Dado el autómata AFD No mı́nimo de la figura 17, minimizarlo aplicando los algoritmos de minimización:Figura 17.</td></tr>
<tr><td>2</td><td>Para el AF D N o mı́nimo de la figura 18, minimizarlo aplicando los algoritmos de minimización:Figura 18.</td></tr>
</table>

<header>
<h3 align="center" id=cons>Construcción de analizadores léxicos definidos
por medio de expresiones regulares</h3>
</header>

<p>Para construir un analizador léxico se parte de la expresión regular, la cual se
transforma en autómata AFN por medio de la construcción de Thompson. Después, el autómata AFN se convierte en autómata AFD utilizando el algoritmo
de subconjuntos, posteriormente se minimiza el número de estados, utilizando
un algoritmo de minimización. Cuando ya se tiene el AFD mı́nimo, este se programa en un lenguaje de programación de alto nivel, ya sea C++, Java, etc. La
programación del AFD mı́nimo, es la implementación del analizador léxico.</p>

Figura 19.

<font color=yellow><h4 align="center">Ejemplo</h4></font>


<p class="p3">
EJEMPLO 5 (Construcción de un analizador léxico.) A
partir de la siguiente expresión regular construir un analizador
léxico: la expresión regular (a|b) ∗ ba, se transforma en
AFN aplicando la construcción de Thompson para tres
concatenaciones, la primera concatenación es una cerradura
de Kleene y dentro de la cerradura de Kleene una alternativa, por
lo que se obtiene el siguiente autómata:
</p>

Figuta 20.

<p>El siguiente paso es convertir el autómata AFN en un autómata AFD
aplicando el algoritmo de subconjuntos. De donde se obtiene el el autómata
AFD no mı́nimo, que se muestra en seguida:</p>

<table CELLSPACING="18">
<tr><td>cerradura-&epsilon;({0}) = </td><td>{ 0, 1, 2, 4, 7 } = S<SUB>0</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>0</SUB> ,a)) = cerradura-&epsilon;({ 3 }) = </td><td>{ 3, 6, 7, 1, 2, 4 } = S<SUB>1</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>0</SUB> ,b)) = cerradura-&epsilon;({ 5 }) = </td><td>{ 5, 6, 7, 1, 2, 4 } = S<SUB>2</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>1</SUB> ,a)) = cerradura-&epsilon;({ 3 }) =</td><td>S<SUB>1</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>1</SUB> ,b)) = cerradura-&epsilon;({ 8, 5 }) = </td><td>{ 8, 5, 6, 7, 1, 2, 4 } = S<SUB>3</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>2</SUB> ,a)) = cerradura-&epsilon;({ 3 }) =</td><td>S<SUB>1</SUB></td></tr>


<tr><td>cerradura-&epsilon;(mov(S<SUB>2</SUB> ,b)) = cerradura-&epsilon;({ 8, 5 }) =</td><td>S<SUB>3</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>3</SUB> ,a)) = cerradura-&epsilon;({ 9, 3 }) = </td><td>  { 9, 3, 6, 7, 1, 2, 4 } = S<SUB>4</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>3</SUB> ,b)) = cerradura-&epsilon;({ 8, 5 }) =</td><td>S<SUB>3</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>4</SUB> ,a)) = cerradura-&epsilon;({ 3 }) =</td><td>S<SUB>1</SUB></td></tr>
<tr><td>cerradura-&epsilon;(mov(S<SUB>4</SUB> ,b)) = cerradura-&epsilon;({ 8, 5 }) =</td><td>S<SUB>3</SUB></td></tr>
</table>


<font color=yellow><h4 align="center">De las operaciones de cerradura se obtiene el AFD:</h4></font>

Figura 21.

<p>Se aplica el algoritmo de minimización del cual se obtiene el autómata
AFD mı́nimo:
Se forma el grupo de estados no finales G<SUB>0</SUB> = {S<SUB>0</SUB>, S<SUB>1</SUB>, S<SUB>2</SUB> , S<SUB>3</SUB> } y el grupo
de estados finales G<SUB>1</SUB> = {S<SUB>4</SUB> }. El grupo G<SUB>1</SUB> por tener un sólo estado es de por
si consistente. Al grupo G<SUB>0</SUB> se le aplica la consistencia y este se divide en dos
grupos: G<SUB>2</SUB> = {S<SUB>0</SUB> , S<SUB>1</SUB> , S<SUB>2</SUB> } y G<SUB>3</SUB> = {S<SUB>3</SUB> }, ası́ que el autómata AFD mı́nimo se
forma como en la figura 22 .</p>

Figura 22.

EJEMPLO 6.

Figura 23.

<p>El autómata AFD de la figura 24 se obtiene aplicando el algoritmo de subconjuntos al autómata AFN de la figura 23 .</p>

Figura 24.

EJEMPLO 7.

Figura 25.

Figura 26.

<p>Aplicando el algoritmo de minimización al AFD de la figura 26 , se obtiene
el autómata AF D M de la figura 27 :</p>

Figura 27.

<p>Se debe construir la función siguiente(), que se muestra a continuación en el
algoritmo :</p>


<img src="ALexAlg5.svg" align=center alt="seleccione aquí para visitar la página oficial de Instraw" width=44% border=0>

<p>Después de haber obtenido la tabla de transiciones del autómata AFD mı́nimo, se aplica el siguiente código para implementar el analizador léxico, escaner
o reconocedor:</p>


<img src="ALexAlg6.svg" align=center alt="seleccione aquí para visitar la página oficial de Instraw" width=44% border=0>

<font color=yellow><h4 align="center">Lista de ejercicios</h4></font>

<p>Dadas las siguientes expresiones regulares construir un analizador léxico:

<table CELLSPACING="18">
<tr><td>1</td><td>a ∗ (a|b)aa</td></tr>
<tr><td>2</td><td>((a|b)(a|bb)) ∗</td></tr>
<tr><td>3</td><td>(ab|ac) ∗</td></tr>
<tr><td>4</td><td>(0|1) ∗ 1100 1 ∗</td></tr>
<tr><td>5</td><td>(01|10|00) ∗ 11</td></tr>
</table>

</p>

<header>
<h3 align="center" id=gen>Generadores de analizadores léxicos</h3>
</header>

<p>Los generadores de analizadores léxicos hacen todo el proceso desde la introducción de la expresión regular, estos generan el autómata mı́nimo ya codificado.
Las especificaciones en FLEX se hace de la siguiente forma:</p>

Código.

<p>En la siguiente tabla 6, se especifican las expresiones regulares en LEX:</p>

Cuadro 6.

<p>El siguiente es un programa en LEX:</p>

Código.


</div>
</article>



<!--Ventana 1-->

<a href="#openModal">FIGURA 1</a>

<div id="openModal" class="modalDialog">
	<div>
		
		<h3><font color=black>FIGURA 1</font></h3>
		<a href="#close" title="Close" class="close">X</a>
		
		
			
	<font color=black>Características de las figuras</font>.<table width="350" cellspacing="1" 				cellpadding="3" border="0" bgcolor="#80A93E" align="center">

			<tr>

   			<td bgcolor="#B7F259" align="center"><font size=4 face="verdana, arial, 			helvetica" color=black><b>Diagrama a bloques del programa objeto.</b></font></td> 
			</tr>

			<tr>

   			<td bgcolor="#F5ECB9"> 
			
			<p><img src="INTfig1.svg" width="500" height="450"></p>
    			
			</td></tr>
			</table>
 			

		
	</div>
</div>

<!--Ventana 2-->

<a href="#openModal1">FIGURA 2</a>

<div id="openModal1" class="modalDialog">
	<div>
		<h3><font color=black>FIGURA 2</font></h3>
		
		<a href="#close" title="Close" class="close">X</a>
		
		
			
		<font color=black>Características de las figuras</font>.<table width="350" 			cellspacing="1" cellpadding="3" border="0" bgcolor="#80A93E" align="center">

			<tr>

   			<td bgcolor="#B7F259" align="center"><font size=4 face="verdana, arial, 			helvetica" color=black><b>Diagrama a bloques de la arquitectura del intérprete.</b></font></td> 
			</tr>

			<tr>

   			<td bgcolor="#F5ECB9"> 
			
			<p><img src="INTfig2.svg" width="500" height="450"></p>
    			
			</td></tr>
			</table>
 			

		
	</div>
</div>

<!--Ventana 3-->

<a href="#openModal2">INTÉRPRETE</a>

<div id="openModal2" class="modalDialog">
	<div>
		
		<h3><font color=black>FIGURA 3</font></h3>

		<a href="#close" title="Close" class="close">X</a>
		
		
			
		<font color=black>Lista de definiciones</font>.<table width="350" cellspacing="1" 				cellpadding="3" border="0" bgcolor="#80A93E" align="center">

			<tr>

   			<td bgcolor="#B7F259" align="center"><font size=4 face="verdana, arial, 			helvetica" color=black><b>Definición de intérprete.</b></font></td> 
			</tr>

			<tr>

   			<td bgcolor="#F5ECB9"> 
			
		<p><font color=black>Otro tipo de traductor, llamado intérprete, procesa en forma 			interna el programa fuente y los datos al mismo tiempo. Es decir, la interpretación 				del formulario de origen interno se produce en tiempo de ejecución y no se 				genera ningún programa objeto.</font></p>
    			
			</td></tr>
			</table>
 			

		
	</div>
</div>

</body>
</html>
